# Python Analytics Engine Container
FROM python:3.11-slim

WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \
    gcc \
    g++ \
    postgresql-client \
    curl \
    && rm -rf /var/lib/apt/lists/*

# Copy requirements and install Python dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Install additional analytics dependencies
RUN pip install --no-cache-dir \
    fastapi \
    uvicorn \
    psycopg2-binary \
    redis \
    scikit-learn \
    numpy \
    scipy

# Copy analytics modules
COPY analytics_engine.py .
COPY mmr_calculator.py .
COPY recommendation_engine.py .
COPY database.py .
COPY riot_api_enhanced.py .

# Create analytics API server
RUN cat > analytics_api.py << 'EOF'
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
import json
import logging
from typing import Dict, Any, List, Optional

from analytics_engine import analytics_engine
from mmr_calculator import MMRAnalyzer
from recommendation_engine import RecommendationEngine

app = FastAPI(title="LoL Analytics Engine API")
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

mmr_analyzer = MMRAnalyzer()
recommendation_engine = RecommendationEngine()

class AnalyticsRequest(BaseModel):
    user_id: int
    period: str = "week"
    
class MMRRequest(BaseModel):
    user_id: int
    days: int = 30
    
class RecommendationRequest(BaseModel):
    user_id: int

@app.get("/health")
async def health_check():
    return {"status": "healthy", "service": "analytics-engine"}

@app.post("/analytics/period")
async def get_period_stats(request: AnalyticsRequest):
    try:
        stats = analytics_engine.generate_period_stats(request.user_id, request.period)
        
        # Convert to dict for JSON serialization
        result = {
            "period": stats.period,
            "total_games": stats.total_games,
            "win_rate": stats.win_rate,
            "avg_kda": stats.avg_kda,
            "best_role": stats.best_role,
            "worst_role": stats.worst_role,
            "top_champions": stats.top_champions,
            "role_performance": {
                role: {
                    "games_played": metrics.games_played,
                    "wins": metrics.wins,
                    "losses": metrics.losses,
                    "win_rate": metrics.win_rate,
                    "avg_kda": metrics.avg_kda,
                    "performance_score": metrics.performance_score,
                    "trend_direction": metrics.trend_direction
                } for role, metrics in stats.role_performance.items()
            },
            "recent_trend": stats.recent_trend,
            "suggestions": stats.suggestions
        }
        
        return {"success": True, "data": result}
    except Exception as e:
        logger.error(f"Error generating period stats: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/analytics/mmr")
async def get_mmr_trajectory(request: MMRRequest):
    try:
        trajectory = mmr_analyzer.calculate_mmr_trajectory(request.user_id, request.days)
        
        if "error" in trajectory:
            return {"success": False, "error": trajectory["error"]}
            
        return {"success": True, "data": trajectory}
    except Exception as e:
        logger.error(f"Error calculating MMR trajectory: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/analytics/recommendations")
async def get_recommendations(request: RecommendationRequest):
    try:
        recommendations = recommendation_engine.generate_recommendations(request.user_id)
        
        # Convert recommendation objects to dicts
        result = []
        for rec in recommendations:
            rec_dict = {
                "type": rec.type.value if hasattr(rec.type, 'value') else str(rec.type),
                "title": rec.title,
                "description": rec.description,
                "priority": rec.priority,
                "confidence": rec.confidence,
                "expected_improvement": rec.expected_improvement,
                "action_items": rec.action_items,
                "time_period": rec.time_period
            }
            
            if rec.champion_id is not None:
                rec_dict["champion_id"] = rec.champion_id
            if rec.role is not None:
                rec_dict["role"] = rec.role
                
            result.append(rec_dict)
        
        return {"success": True, "data": result}
    except Exception as e:
        logger.error(f"Error generating recommendations: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/analytics/process_match")
async def process_match(match_id: str, user_id: int):
    """Process a new match through analytics engines"""
    try:
        # This would process the match through all analytics
        analytics_engine.update_champion_stats(user_id, "all")
        
        return {"success": True, "message": f"Match {match_id} processed"}
    except Exception as e:
        logger.error(f"Error processing match: {e}")
        raise HTTPException(status_code=500, detail=str(e))

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=5000)
EOF

# Expose port
EXPOSE 5000

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:5000/health || exit 1

# Run the analytics API server
CMD ["python", "-u", "analytics_api.py"]