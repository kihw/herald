package services

import (
	"database/sql"
	"fmt"
	"time"
	"lol-match-exporter/internal/models"
)

// UserService handles user-related business logic
type UserService struct {
	db *sql.DB
}

// NewUserService creates a new user service
func NewUserService(db *sql.DB) *UserService {
	return &UserService{db: db}
}

// CreateOrUpdateUserFromOAuth creates or updates a user from OAuth data
func (us *UserService) CreateOrUpdateUserFromOAuth(riotUserInfo *models.RiotUserInfo, tokenData *models.RiotOAuthTokenResponse, region string) (*models.User, error) {
	// Check if user already exists by PUUID
	existingUser, _ := us.GetUserByPUUID(riotUserInfo.Sub)
	
	if existingUser != nil {
		// Update existing user
		existingUser.RiotID = riotUserInfo.Acct.GameName
		existingUser.RiotTag = riotUserInfo.Acct.TagLine
		existingUser.AccessToken = &tokenData.AccessToken
		existingUser.RefreshToken = &tokenData.RefreshToken
		expiresAt := time.Now().Add(time.Duration(tokenData.ExpiresIn) * time.Second)
		existingUser.TokenExpiresAt = &expiresAt
		existingUser.Region = region
		existingUser.UpdatedAt = time.Now()
		
		err := us.UpdateUser(existingUser)
		if err != nil {
			return nil, fmt.Errorf("failed to update existing user: %w", err)
		}
		return existingUser, nil
	}
	
	// Create new user
	user := &models.User{
		RiotID:       riotUserInfo.Acct.GameName,
		RiotTag:      riotUserInfo.Acct.TagLine,
		RiotPUUID:    riotUserInfo.Sub,
		Region:       region,
		AccessToken:  &tokenData.AccessToken,
		RefreshToken: &tokenData.RefreshToken,
	}
	
	expiresAt := time.Now().Add(time.Duration(tokenData.ExpiresIn) * time.Second)
	user.TokenExpiresAt = &expiresAt
	
	query := `
		INSERT INTO users (riot_id, riot_tag, riot_puuid, region, access_token, refresh_token, token_expires_at, created_at, updated_at)
		VALUES ($1, $2, $3, $4, $5, $6, $7, NOW(), NOW())
		RETURNING id, created_at, updated_at`
	
	err := us.db.QueryRow(query, user.RiotID, user.RiotTag, user.RiotPUUID, user.Region,
		user.AccessToken, user.RefreshToken, user.TokenExpiresAt).
		Scan(&user.ID, &user.CreatedAt, &user.UpdatedAt)
	
	if err != nil {
		return nil, fmt.Errorf("failed to create user: %w", err)
	}

	// Create default user settings
	settings := &models.UserSettings{
		UserID:               user.ID,
		Platform:             region,
		QueueTypes:           []int64{420, 440}, // Ranked Solo/Duo, Ranked Flex
		Language:             "en_US",
		IncludeTimeline:      true,
		IncludeAllData:       true,
		LightMode:            true,
		AutoSyncEnabled:      true,
		SyncFrequencyHours:   24,
	}

	err = us.CreateUserSettings(settings)
	if err != nil {
		return nil, fmt.Errorf("failed to create user settings: %w", err)
	}

	return user, nil
}

// GetUserByPUUID retrieves a user by Riot PUUID
func (us *UserService) GetUserByPUUID(puuid string) (*models.User, error) {
	user := &models.User{}
	query := `
		SELECT id, riot_id, riot_tag, riot_puuid, summoner_id, account_id, profile_icon_id, 
			   summoner_level, region, last_region_used, access_token, refresh_token, 
			   token_expires_at, created_at, updated_at, last_sync
		FROM users WHERE riot_puuid = $1`
	
	err := us.db.QueryRow(query, puuid).Scan(
		&user.ID, &user.RiotID, &user.RiotTag, &user.RiotPUUID,
		&user.SummonerID, &user.AccountID, &user.ProfileIconID, &user.SummonerLevel,
		&user.Region, &user.LastRegionUsed, &user.AccessToken, &user.RefreshToken,
		&user.TokenExpiresAt, &user.CreatedAt, &user.UpdatedAt, &user.LastSync,
	)
	
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("user not found")
		}
		return nil, fmt.Errorf("failed to get user: %w", err)
	}
	
	return user, nil
}

// GetUserByID retrieves a user by ID
func (us *UserService) GetUserByID(id int) (*models.User, error) {
	user := &models.User{}
	query := `
		SELECT id, riot_id, riot_tag, riot_puuid, summoner_id, account_id, profile_icon_id, 
			   summoner_level, region, last_region_used, access_token, refresh_token, 
			   token_expires_at, created_at, updated_at, last_sync
		FROM users WHERE id = $1`
	
	err := us.db.QueryRow(query, id).Scan(
		&user.ID, &user.RiotID, &user.RiotTag, &user.RiotPUUID,
		&user.SummonerID, &user.AccountID, &user.ProfileIconID, &user.SummonerLevel,
		&user.Region, &user.LastRegionUsed, &user.AccessToken, &user.RefreshToken,
		&user.TokenExpiresAt, &user.CreatedAt, &user.UpdatedAt, &user.LastSync,
	)
	
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("user not found")
		}
		return nil, fmt.Errorf("failed to get user: %w", err)
	}
	
	return user, nil
}

// UpdateUser updates user information
func (us *UserService) UpdateUser(user *models.User) error {
	query := `
		UPDATE users 
		SET riot_id = $2, riot_tag = $3, riot_puuid = $4, summoner_id = $5,
			account_id = $6, profile_icon_id = $7, summoner_level = $8, region = $9,
			last_region_used = $10, access_token = $11, refresh_token = $12, 
			token_expires_at = $13, updated_at = NOW()
		WHERE id = $1`
	
	_, err := us.db.Exec(query, user.ID, user.RiotID, user.RiotTag, user.RiotPUUID,
		user.SummonerID, user.AccountID, user.ProfileIconID, user.SummonerLevel,
		user.Region, user.LastRegionUsed, user.AccessToken, user.RefreshToken, user.TokenExpiresAt)
	
	if err != nil {
		return fmt.Errorf("failed to update user: %w", err)
	}
	
	return nil
}

// UpdateLastSync updates the user's last sync timestamp
func (us *UserService) UpdateLastSync(userID int) error {
	query := `UPDATE users SET last_sync = NOW() WHERE id = $1`
	_, err := us.db.Exec(query, userID)
	if err != nil {
		return fmt.Errorf("failed to update last sync: %w", err)
	}
	return nil
}

// CreateUserSettings creates user settings
func (us *UserService) CreateUserSettings(settings *models.UserSettings) error {
	query := `
		INSERT INTO user_settings (user_id, platform, queue_types, language, include_timeline,
			include_all_data, light_mode, auto_sync_enabled, sync_frequency_hours, created_at, updated_at)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, NOW(), NOW())
		RETURNING id, created_at, updated_at`
	
	err := us.db.QueryRow(query, settings.UserID, settings.Platform, settings.QueueTypes,
		settings.Language, settings.IncludeTimeline, settings.IncludeAllData, settings.LightMode,
		settings.AutoSyncEnabled, settings.SyncFrequencyHours).
		Scan(&settings.ID, &settings.CreatedAt, &settings.UpdatedAt)
	
	if err != nil {
		return fmt.Errorf("failed to create user settings: %w", err)
	}
	
	return nil
}

// GetUserSettings retrieves user settings
func (us *UserService) GetUserSettings(userID int) (*models.UserSettings, error) {
	settings := &models.UserSettings{}
	query := `
		SELECT id, user_id, platform, queue_types, language, include_timeline,
			   include_all_data, light_mode, auto_sync_enabled, sync_frequency_hours,
			   created_at, updated_at
		FROM user_settings WHERE user_id = $1`
	
	err := us.db.QueryRow(query, userID).Scan(
		&settings.ID, &settings.UserID, &settings.Platform, &settings.QueueTypes,
		&settings.Language, &settings.IncludeTimeline, &settings.IncludeAllData,
		&settings.LightMode, &settings.AutoSyncEnabled, &settings.SyncFrequencyHours,
		&settings.CreatedAt, &settings.UpdatedAt,
	)
	
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("user settings not found")
		}
		return nil, fmt.Errorf("failed to get user settings: %w", err)
	}
	
	return settings, nil
}

// UpdateUserSettings updates user settings
func (us *UserService) UpdateUserSettings(settings *models.UserSettings) error {
	query := `
		UPDATE user_settings 
		SET platform = $2, queue_types = $3, language = $4, include_timeline = $5,
			include_all_data = $6, light_mode = $7, auto_sync_enabled = $8,
			sync_frequency_hours = $9, updated_at = NOW()
		WHERE user_id = $1`
	
	_, err := us.db.Exec(query, settings.UserID, settings.Platform, settings.QueueTypes,
		settings.Language, settings.IncludeTimeline, settings.IncludeAllData,
		settings.LightMode, settings.AutoSyncEnabled, settings.SyncFrequencyHours)
	
	if err != nil {
		return fmt.Errorf("failed to update user settings: %w", err)
	}
	
	return nil
}

// GetDashboardStats calculates user dashboard statistics
func (us *UserService) GetDashboardStats(userID int) (*models.DashboardStats, error) {
	stats := &models.DashboardStats{}
	
	// Get total matches and win rate
	query := `
		SELECT 
			COUNT(*) as total_matches,
			COALESCE(AVG(CASE WHEN win THEN 1.0 ELSE 0.0 END) * 100, 0) as win_rate
		FROM match_participants 
		WHERE user_id = $1`
	
	err := us.db.QueryRow(query, userID).Scan(&stats.TotalMatches, &stats.WinRate)
	if err != nil {
		return nil, fmt.Errorf("failed to get basic stats: %w", err)
	}
	
	// Get average KDA
	query = `
		SELECT COALESCE(AVG(
			CASE WHEN deaths = 0 THEN kills + assists 
			ELSE (kills + assists)::float / deaths 
			END
		), 0) as avg_kda
		FROM match_participants 
		WHERE user_id = $1`
	
	err = us.db.QueryRow(query, userID).Scan(&stats.AverageKDA)
	if err != nil {
		return nil, fmt.Errorf("failed to get KDA stats: %w", err)
	}
	
	// Get favorite champion
	query = `
		SELECT COALESCE(champion_name, 'Unknown') as favorite_champion
		FROM match_participants 
		WHERE user_id = $1 AND champion_name IS NOT NULL
		GROUP BY champion_name 
		ORDER BY COUNT(*) DESC 
		LIMIT 1`
	
	err = us.db.QueryRow(query, userID).Scan(&stats.FavoriteChampion)
	if err != nil && err != sql.ErrNoRows {
		return nil, fmt.Errorf("failed to get favorite champion: %w", err)
	}
	
	// Get last sync time
	query = `SELECT last_sync FROM users WHERE id = $1`
	err = us.db.QueryRow(query, userID).Scan(&stats.LastSyncAt)
	if err != nil && err != sql.ErrNoRows {
		return nil, fmt.Errorf("failed to get last sync: %w", err)
	}
	
	// Calculate next sync time (if auto sync enabled)
	settings, err := us.GetUserSettings(userID)
	if err == nil && settings.AutoSyncEnabled && stats.LastSyncAt != nil {
		nextSync := stats.LastSyncAt.Add(time.Duration(settings.SyncFrequencyHours) * time.Hour)
		stats.NextSyncAt = &nextSync
	}
	
	return stats, nil
}

// CanUserSync checks if user can perform a manual sync (respects cooldown)
func (us *UserService) CanUserSync(userID int, cooldownMinutes int) (bool, time.Duration, error) {
	var lastSync *time.Time
	query := `SELECT last_sync FROM users WHERE id = $1`
	err := us.db.QueryRow(query, userID).Scan(&lastSync)
	if err != nil && err != sql.ErrNoRows {
		return false, 0, fmt.Errorf("failed to check sync status: %w", err)
	}
	
	if lastSync == nil {
		return true, 0, nil // Never synced before
	}
	
	cooldownDuration := time.Duration(cooldownMinutes) * time.Minute
	timeSinceLastSync := time.Since(*lastSync)
	
	if timeSinceLastSync >= cooldownDuration {
		return true, 0, nil
	}
	
	remainingCooldown := cooldownDuration - timeSinceLastSync
	return false, remainingCooldown, nil
}
