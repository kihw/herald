package handlers

import (
	"fmt"
	"net/http"

	"lol-match-exporter/internal/auth"
	"lol-match-exporter/internal/models"
	"lol-match-exporter/internal/services"

	"github.com/gin-gonic/gin"
)

type AuthHandler struct {
	authService *auth.AuthService
	userService *services.UserService
	syncService *services.SyncService
	demoService *services.DemoService
}

func NewAuthHandler(authService *auth.AuthService, userService *services.UserService, syncService *services.SyncService, demoService *services.DemoService) *AuthHandler {
	return &AuthHandler{
		authService: authService,
		userService: userService,
		syncService: syncService,
		demoService: demoService,
	}
}

// Register handles user registration
func (h *AuthHandler) Register(c *gin.Context) {
	var req models.RegisterRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Validate password strength
	if err := h.authService.PasswordStrength(req.Password); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Hash password
	hashedPassword, err := h.authService.HashPassword(req.Password)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to process password"})
		return
	}

	// Create user
	user := &models.User{
		Username:     req.Username,
		Tagline:      req.Tagline,
		Email:        req.Email,
		PasswordHash: hashedPassword,
	}

	err = h.userService.CreateUser(user)
	if err != nil {
		if contains(err.Error(), "duplicate key") || contains(err.Error(), "already exists") {
			c.JSON(http.StatusConflict, gin.H{"error": "User already exists"})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create user"})
		return
	}

	// Create session
	session, err := h.authService.CreateSession(user.ID, user.Username, user.Email)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create session"})
		return
	}

	// Return success response
	user.PasswordHash = "" // Don't send password hash
	c.JSON(http.StatusCreated, models.AuthResponse{
		User:         *user,
		AccessToken:  session.Token,
		RefreshToken: session.Token, // Using same token for simplicity
		ExpiresIn:    int(session.ExpiresAt.Sub(session.CreatedAt).Seconds()),
	})
}

// Login handles user authentication
func (h *AuthHandler) Login(c *gin.Context) {
	var req models.LoginRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// Get user by email
	user, err := h.userService.GetUserByEmail(req.Email)
	if err != nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid credentials"})
		return
	}

	// Verify password
	if err := h.authService.VerifyPassword(req.Password, user.PasswordHash); err != nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid credentials"})
		return
	}

	// Create session
	session, err := h.authService.CreateSession(user.ID, user.Username, user.Email)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create session"})
		return
	}

	// Return success response
	user.PasswordHash = "" // Don't send password hash
	c.JSON(http.StatusOK, models.AuthResponse{
		User:         *user,
		AccessToken:  session.Token,
		RefreshToken: session.Token, // Using same token for simplicity
		ExpiresIn:    int(session.ExpiresAt.Sub(session.CreatedAt).Seconds()),
	})
}

// Logout handles user logout
func (h *AuthHandler) Logout(c *gin.Context) {
	token := c.GetHeader("Authorization")
	if token == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "No token provided"})
		return
	}

	// Remove "Bearer " prefix if present
	if len(token) > 7 && token[:7] == "Bearer " {
		token = token[7:]
	}

	h.authService.DeleteSession(token)
	c.JSON(http.StatusOK, gin.H{"message": "Logged out successfully"})
}

// Profile returns the current user's profile
func (h *AuthHandler) Profile(c *gin.Context) {
	session, exists := c.Get("session")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
		return
	}

	userSession := session.(*auth.Session)
	user, err := h.userService.GetUserByID(userSession.UserID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get user"})
		return
	}

	user.PasswordHash = "" // Don't send password hash
	c.JSON(http.StatusOK, user)
}

// Dashboard returns dashboard statistics
func (h *AuthHandler) Dashboard(c *gin.Context) {
	session, exists := c.Get("session")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
		return
	}

	userSession := session.(*auth.Session)
	stats, err := h.userService.GetDashboardStats(userSession.UserID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get dashboard stats"})
		return
	}

	c.JSON(http.StatusOK, stats)
}

// UpdateSettings updates user settings
func (h *AuthHandler) UpdateSettings(c *gin.Context) {
	session, exists := c.Get("session")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
		return
	}

	userSession := session.(*auth.Session)
	
	var settings models.UserSettings
	if err := c.ShouldBindJSON(&settings); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	settings.UserID = userSession.UserID
	err := h.userService.UpdateUserSettings(&settings)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update settings"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "Settings updated successfully"})
}

// GetSettings returns user settings
func (h *AuthHandler) GetSettings(c *gin.Context) {
	session, exists := c.Get("session")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
		return
	}

	userSession := session.(*auth.Session)
	settings, err := h.userService.GetUserSettings(userSession.UserID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get settings"})
		return
	}

	c.JSON(http.StatusOK, settings)
}

// Sync handles manual synchronization request
func (h *AuthHandler) Sync(c *gin.Context) {
	session, exists := c.Get("session")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
		return
	}

	userSession := session.(*auth.Session)
	
	var req models.SyncRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		// Default values if no body provided
		req.Force = false
	}

	// Check cooldown unless forced
	if !req.Force {
		canSync, remainingTime, err := h.userService.CanUserSync(userSession.UserID, 2) // 2 minutes cooldown
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to check sync status"})
			return
		}

		if !canSync {
			c.JSON(http.StatusTooManyRequests, models.SyncResponse{
				Status:  "cooldown",
				Message: fmt.Sprintf("Please wait %v before syncing again", remainingTime),
			})
			return
		}
	}

	// Récupérer les informations de l'utilisateur
	user, err := h.userService.GetUserByID(userSession.UserID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get user info"})
		return
	}

	// Démarrer la synchronisation
	err = h.syncService.SyncUserMatches(userSession.UserID, user.Username, user.Tagline)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("Sync failed: %v", err)})
		return
	}

	c.JSON(http.StatusOK, models.SyncResponse{
		Status:  "completed",
		Message: "Synchronization completed successfully",
	})
}

// SyncDemo génère des données de démonstration pour l'utilisateur
func (h *AuthHandler) SyncDemo(c *gin.Context) {
	session, exists := c.Get("session")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
		return
	}

	userSession := session.(*auth.Session)

	// Récupérer les informations de l'utilisateur
	user, err := h.userService.GetUserByID(userSession.UserID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get user info"})
		return
	}

	// Vérifier et définir des valeurs par défaut pour username/tagline
	username := user.Username
	tagline := user.Tagline
	if username == "" {
		username = "DemoUser"
	}
	if tagline == "" {
		tagline = "DEMO"
	}

	// Générer des données de démonstration
	log.Printf("🎮 Generating demo matches for user %d (%s#%s)", userSession.UserID, username, tagline)
	err = h.demoService.GenerateDemoMatches(userSession.UserID, username, tagline)
	if err != nil {
		log.Printf("❌ Demo sync failed for user %d: %v", userSession.UserID, err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("Demo sync failed: %v", err)})
		return
	}

	// Mettre à jour la date de dernière synchronisation
	err = h.userService.UpdateLastSync(userSession.UserID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update sync time"})
		return
	}

	c.JSON(http.StatusOK, models.SyncResponse{
		Status:  "completed",
		Message: "Demo synchronization completed successfully - 15 demo matches generated",
	})
}

// AuthMiddleware validates session tokens
func (h *AuthHandler) AuthMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		token := c.GetHeader("Authorization")
		if token == "" {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "No token provided"})
			c.Abort()
			return
		}

		// Remove "Bearer " prefix if present
		if len(token) > 7 && token[:7] == "Bearer " {
			token = token[7:]
		}

		session, err := h.authService.ValidateSession(token)
		if err != nil {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid or expired token"})
			c.Abort()
			return
		}

		// Store session in context
		c.Set("session", session)
		c.Next()
	}
}

// Helper function to check if string contains substring
func contains(s, substr string) bool {
	return len(s) >= len(substr) && (s == substr || (len(s) > len(substr) && 
		(s[:len(substr)] == substr || s[len(s)-len(substr):] == substr || containsInner(s, substr))))
}

func containsInner(s, substr string) bool {
	for i := 0; i <= len(s)-len(substr); i++ {
		if s[i:i+len(substr)] == substr {
			return true
		}
	}
	return false
}
